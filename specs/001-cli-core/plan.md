# Implementation Plan: TaskFlow CLI Core

**Branch**: `001-cli-core` | **Date**: 2025-12-07 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-cli-core/spec.md`

---

## Summary

Build a command-line interface that proves **human-agent parity** in task management. The CLI enables project initialization, worker registration (both human and agent), complete task lifecycle management, and comprehensive audit trails. Core innovation: `taskflow worker add @claude-code --type agent` works identically to `taskflow worker add @sarah --type human`.

**Technical Approach**: Python 3.13+ with Typer for CLI framework, Pydantic models for data validation, JSON file storage (transitioning to SQLModel in Phase II), and Rich for terminal output. Implementation follows 3-sprint structure targeting 69-minute completion.

---

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: Typer (CLI), Pydantic (models), Rich (terminal output), UV (package management)
**Storage**: JSON files in `.taskflow/` directory (Phase I only; SQLModel + PostgreSQL in Phase II)
**Testing**: pytest with unit and integration tests
**Target Platform**: macOS, Linux, WSL2 (Windows via Ubuntu on WSL2)
**Project Type**: Single Python package with CLI entry point
**Performance Goals**:
- Command execution < 100ms for basic operations
- Support 1000+ tasks without performance degradation
- Search/filter operations < 1 second for 1000 tasks

**Constraints**:
- Phase I only: No database, no web UI, no authentication
- Single-user mode (multi-user in Phase II)
- JSON storage must be forward-compatible with SQLModel schemas
- 69-minute implementation target (demo-ready, not production-complete)

**Scale/Scope**:
- Demo mode with 5-10 sample tasks
- Support unlimited projects, workers, and tasks (JSON file limits apply)
- Audit trail captures every state change

---

## Constitution Check

*GATE: Must pass before implementation. Re-check after completion.*

### Principle 1: Every Action MUST Be Auditable
- âœ… **PASS**: All state-changing commands (init, add, start, progress, complete, review, approve, reject, delegate) create audit log entries
- âœ… **PASS**: Audit entries include: task_id, actor_id, actor_type (human|agent), action, timestamp, context
- âœ… **PASS**: `taskflow audit <id>` command displays complete chronological history

### Principle 2: Agents Are First-Class Citizens
- âœ… **PASS**: Workers table supports both `human` and `agent` types
- âœ… **PASS**: `taskflow worker add @claude-code --type agent` uses identical syntax to human registration
- âœ… **PASS**: Task assignment, delegation, and workflow commands work identically for both types
- âœ… **PASS**: Audit trail records human and agent actions with same granularity (only `actor_type` differs)

### Principle 3: Recursive Task Decomposition
- âœ… **PASS**: Task model includes `parent_id` field (nullable for root tasks)
- âœ… **PASS**: `taskflow add "title" --parent <id>` enables subtask creation
- âœ… **PASS**: `taskflow show <id>` displays subtask hierarchy
- âœ… **PASS**: No depth limit on nesting (circular reference prevention implemented)

### Principle 4: Spec-Driven Development
- âœ… **PASS**: Complete specification exists at `/specs/001-cli-core/spec.md`
- âœ… **PASS**: This plan generated from spec + constitution
- âœ… **PASS**: Implementation will be generated by Claude Code from spec + plan

### Principle 5: Phase Continuity (Data Model Persistence)
- âœ… **PASS**: Pydantic models designed to become SQLModel with minimal changes
- âœ… **PASS**: Field names, types, and relationships match future database schema
- âœ… **PASS**: Audit log structure persists through all 5 phases
- âœ… **PASS**: JSON storage uses same structure as future PostgreSQL tables

**Result**: âœ… All constitutional principles satisfied. Proceed to implementation.

---

## Project Structure

### Documentation (this feature)

```text
specs/001-cli-core/
â”œâ”€â”€ spec.md              # Feature specification (40 functional requirements)
â”œâ”€â”€ plan.md              # This file (implementation plan)
â””â”€â”€ tasks.md             # Task breakdown (generated by /sp.tasks - NOT YET CREATED)
```

### Source Code (repository root)

```text
src/taskflow/                 # Python package root
â”œâ”€â”€ __init__.py              # Package initialization
â”œâ”€â”€ main.py                  # Typer app entry point (CLI runner)
â”œâ”€â”€ models.py                # Pydantic data models (Task, Worker, Project, AuditLog)
â”œâ”€â”€ storage.py               # JSON file storage layer (load, save, lock)
â”œâ”€â”€ audit.py                 # Audit logging utilities
â”œâ”€â”€ config.py                # Configuration management (.taskflow/config.json)
â””â”€â”€ commands/                # CLI command modules (Typer command groups)
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ init.py              # `taskflow init`
    â”œâ”€â”€ project.py           # `taskflow project add|list`
    â”œâ”€â”€ worker.py            # `taskflow worker add|list`, `taskflow agent add`
    â”œâ”€â”€ task.py              # `taskflow add|list|show|edit|delete`
    â”œâ”€â”€ workflow.py          # `taskflow start|progress|complete|review|approve|reject|delegate`
    â”œâ”€â”€ audit.py             # `taskflow audit <id>`
    â”œâ”€â”€ config.py            # `taskflow config set <key> <value>`
    â”œâ”€â”€ demo.py              # `taskflow demo [-i]`
    â””â”€â”€ interactive.py       # `taskflow interactive` or `taskflow -i`

tests/
â”œâ”€â”€ conftest.py              # pytest fixtures (temp .taskflow dir, sample data)
â”œâ”€â”€ test_models.py           # Unit tests for Pydantic models
â”œâ”€â”€ test_storage.py          # Unit tests for storage layer
â”œâ”€â”€ test_audit.py            # Unit tests for audit logging
â”œâ”€â”€ test_init.py             # Integration tests for init command
â”œâ”€â”€ test_project.py          # Integration tests for project commands
â”œâ”€â”€ test_worker.py           # Integration tests for worker commands
â”œâ”€â”€ test_task.py             # Integration tests for task commands
â”œâ”€â”€ test_workflow.py         # Integration tests for workflow commands
â””â”€â”€ test_demo.py             # Integration test for demo script

pyproject.toml               # UV package configuration
README.md                    # Setup and usage instructions
CLAUDE.md                    # Claude Code instructions (already exists)
.taskflow/                   # Created by `taskflow init` (gitignored)
â”œâ”€â”€ config.json              # User config (default_project, current_user)
â””â”€â”€ data.json                # All data (projects, workers, tasks, audit_logs)
```

**Structure Decision**: Single Python package structure selected because:
- Phase I is CLI-only (no frontend/backend split)
- Monorepo structure with `/src/taskflow` enables future phases to add `/frontend`, `/backend`, `/mcp-server` alongside
- UV package manager supports this layout natively
- Forward-compatible with Phase II SQLModel migration (models.py becomes ORM models)

---

## Complexity Tracking

> **No constitutional violations detected.** This section intentionally left minimal.

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| N/A | N/A | N/A |

---

## 1. Technical Architecture

### Module Dependency Graph

```
Layer 1: Core Data Models (no dependencies)
â””â”€â”€ models.py
    - Project, Worker, Task, AuditLog (Pydantic models)
    - Status transition validation
    - Worker type validation

Layer 2: Infrastructure (depends on Layer 1)
â”œâ”€â”€ storage.py
â”‚   - JSON file operations
â”‚   - File locking (fcntl)
â”‚   - CRUD methods
â”‚
â”œâ”€â”€ audit.py
â”‚   - Audit log creation helpers
â”‚   - Actor detection
â”‚
â””â”€â”€ config.py
    - Configuration management
    - Default project handling
    - Current user tracking

Layer 3: Command Layer (depends on Layers 1-2)
â””â”€â”€ commands/
    â”œâ”€â”€ init.py (depends on: storage, config)
    â”œâ”€â”€ project.py (depends on: storage, audit, models)
    â”œâ”€â”€ worker.py (depends on: storage, audit, models)
    â”œâ”€â”€ task.py (depends on: storage, audit, models, config)
    â”œâ”€â”€ workflow.py (depends on: storage, audit, models, config)
    â”œâ”€â”€ audit.py (depends on: storage, models)
    â”œâ”€â”€ config.py (depends on: config module)
    â””â”€â”€ demo.py (depends on: all commands)

Layer 4: CLI Entry Point
â””â”€â”€ main.py
    - Typer app registration
    - Command routing
    - Global options
```

### Data Flow for Key Operations

**Task Creation Flow**:
```
User: taskflow add "Implement auth" --assign @claude-code --priority high

1. commands/task.py::add_task()
   â†“
2. Load config â†’ get current_user, default_project
   â†“
3. Create Task Pydantic model (validates fields)
   â†“
4. storage.add_task(task) â†’ assigns ID, saves to JSON
   â†“
5. audit.log_action(entity="task", action="created", actor=current_user)
   â†“
6. Display confirmation with Rich console
```

**Status Transition Flow**:
```
User: taskflow start 1

1. commands/workflow.py::start_task(task_id=1)
   â†“
2. storage.get_task(1) â†’ Load current task
   â†“
3. models.validate_status_transition(current="pending", next="in_progress")
   â†“
4. Update task.status, task.updated_at
   â†“
5. storage.update_task(task)
   â†“
6. audit.log_action(entity="task", action="started", actor=current_user)
   â†“
7. Display success message
```

**Audit Trail Query Flow**:
```
User: taskflow audit 1

1. commands/audit.py::show_audit(task_id=1)
   â†“
2. storage.get_audit_logs(task_id=1)
   â†“
3. Filter logs by entity_type="task", entity_id=1
   â†“
4. Sort by timestamp ascending
   â†“
5. Rich table rendering (timestamp, actor, action, context)
   â†“
6. Display formatted audit trail
```

---

## 2. Component Breakdown with Dependencies

### Core Layer

#### models.py
**Purpose**: Pydantic data models with validation.

**Dependencies**: None (Pydantic only)

**Components**:
- `Project` model: id (slug), name, description, owner_id, created_at
- `Worker` model: id (@handle), type (human|agent), name, agent_type, capabilities, created_at
- `Task` model: id, project_id, title, description, assignee_id, created_by_id, parent_id, status, progress_percent, priority, tags, due_date, recurrence, created_at, updated_at
- `AuditLog` model: id, entity_type, entity_id, action, actor_id, actor_type, context, created_at
- `VALID_TRANSITIONS` dict: Finite state machine for status changes
- `validate_status_transition()` function: Checks current â†’ next status validity

**Implementation Notes**:
- Use Pydantic v2 validators for @handle format validation
- Worker model has cross-field validation (agent_type required if type="agent")
- Task model supports unlimited subtask depth (parent_id nullable)

---

#### storage.py
**Purpose**: JSON file storage with file locking.

**Dependencies**: models.py, Path, json, fcntl

**Components**:
- `Storage` class
  - `__init__(base_dir)`: Initialize paths to .taskflow/config.json and data.json
  - `_file_lock(file_path)`: Context manager for advisory file locks
  - `initialize(default_project, current_user)`: Create initial JSON files
  - `load_data()`: Read data.json with lock
  - `save_data(data)`: Write data.json with lock
  - `load_config()`, `save_config(config)`: Config operations
  - CRUD methods:
    - `add_project(project)`, `get_projects()`, `get_project(id)`
    - `add_worker(worker)`, `get_workers()`, `get_worker(id)`
    - `add_task(task) -> int`, `get_task(id)`, `update_task(task)`, `delete_task(id)`, `get_tasks(filters)`
    - `add_audit_log(log)`, `get_audit_logs(task_id=None)`

**Implementation Notes**:
- File locking uses `fcntl.flock()` (Unix) for advisory locks
- Auto-increment IDs via `_metadata.next_task_id` counter
- All saves are atomic (read-modify-write under lock)

---

#### audit.py
**Purpose**: Audit logging utilities.

**Dependencies**: models.py, storage.py, datetime

**Components**:
- `log_action(entity_type, entity_id, action, actor_id, actor_type, context={})`
  - Creates AuditLog entry
  - Calls storage.add_audit_log()
- `get_actor_type(actor_id, storage) -> Literal["human", "agent"]`
  - Looks up worker by ID to determine type

**Implementation Notes**:
- Always called after state changes (create, update, status change)
- Context dict stores action-specific details (e.g., {"percent": 50, "note": "..."})

---

#### config.py
**Purpose**: Configuration management.

**Dependencies**: storage.py

**Components**:
- `get_config(storage) -> dict`: Loads current config
- `set_config(storage, key, value)`: Updates config key
- `get_current_user(storage) -> str`: Returns current_user @handle
- `get_default_project(storage) -> str`: Returns default_project slug

**Implementation Notes**:
- Config keys: `default_project`, `current_user`, `storage_mode`, `version`
- Used by all commands to get context (who is acting, which project)

---

### Command Layer

#### commands/init.py
**Purpose**: Initialize TaskFlow in current directory.

**Dependencies**: storage, config, typer, rich

**Commands**:
- `taskflow init`
  - Prompts for user @handle
  - Creates `.taskflow/` directory
  - Initializes config.json and data.json
  - Creates default project

**Implementation Notes**:
- Check if `.taskflow/` already exists (error if yes)
- Validate @handle format before saving

---

#### commands/project.py
**Purpose**: Project management.

**Dependencies**: storage, audit, models, typer, rich

**Commands**:
- `taskflow project add <id> --name "Name" --description "Desc"`
  - Creates Project model
  - Validates slug format
  - Saves to storage
  - Creates audit log

- `taskflow project list`
  - Fetches all projects
  - Displays Rich table (ID, Name, Owner, Created)

**Implementation Notes**:
- Project ID must be slug format: `^[a-z0-9_-]+$`
- Owner defaults to current_user from config

---

#### commands/worker.py
**Purpose**: Worker registration (human + agent).

**Dependencies**: storage, audit, models, typer, rich

**Commands**:
- `taskflow worker add @handle --type human`
  - Creates Worker model (type=human, agent_type=None)
  - Saves to storage
  - Creates audit log

- `taskflow agent add @handle --capabilities coding,research`
  - Creates Worker model (type=agent, agent_type=claude)
  - Parses capabilities list
  - Saves to storage
  - Creates audit log

- `taskflow worker list`
  - Fetches all workers
  - Displays Rich table (ID, Type, Name, Capabilities)
  - Uses emoji badges (ðŸ‘¤ human, ðŸ¤– agent)

**Implementation Notes**:
- Validate @handle format: `^@[a-z0-9_-]+$`
- agent_type defaults to "claude" in `agent add` (can add --agent-type option)
- Capabilities split by comma

---

#### commands/task.py
**Purpose**: Task CRUD operations.

**Dependencies**: storage, audit, models, config, typer, rich

**Commands**:
- `taskflow add "title" --assign @worker --priority high --tags api,security --parent <id> --desc "description"`
  - Creates Task model
  - Validates assignee exists
  - Validates parent exists (if specified)
  - Checks for circular refs
  - Auto-assigns ID via storage
  - Creates audit log

- `taskflow list --status pending --assignee @claude --priority high --tag api --search "auth"`
  - Fetches tasks with filters
  - Displays Rich table (ID, Title, Status, Assignee, Priority, Progress)
  - Color-codes status

- `taskflow show <id>`
  - Fetches task by ID
  - Fetches subtasks (tasks with parent_id == id)
  - Fetches recent audit logs
  - Displays Rich panels (task details, subtasks tree, audit trail)

- `taskflow edit <id> --title "New" --priority low --assignee @new`
  - Updates task fields
  - Creates audit log
  - Displays confirmation

- `taskflow delete <id>`
  - Checks for subtasks (prompt confirmation if exists)
  - Deletes task
  - Creates audit log

**Implementation Notes**:
- Search performs case-insensitive substring match on title + description
- Filter by status supports "all", "pending", "in_progress", "review", "completed", "blocked"
- Sort options: created_at, updated_at, priority, due_date, title

---

#### commands/workflow.py
**Purpose**: Task lifecycle management.

**Dependencies**: storage, audit, models, config, typer, rich

**Commands**:
- `taskflow start <id>`
  - Validates status transition (pending â†’ in_progress)
  - Updates task.status
  - Creates audit log

- `taskflow progress <id> --percent 60 --note "Halfway"`
  - Updates task.progress_percent
  - Creates audit log with note in context

- `taskflow complete <id>`
  - Validates status transition (in_progress â†’ completed)
  - Sets status = "completed", progress = 100
  - Creates audit log

- `taskflow review <id>`
  - Validates status transition (in_progress â†’ review)
  - Sets status = "review"
  - Creates audit log

- `taskflow approve <id>`
  - Validates status transition (review â†’ completed)
  - Sets status = "completed", progress = 100
  - Creates audit log

- `taskflow reject <id> --reason "Needs tests"`
  - Validates status transition (review â†’ in_progress)
  - Sets status = "in_progress"
  - Creates audit log with reason in context

- `taskflow delegate <id> @new-worker --note "Reassigning"`
  - Validates new assignee exists
  - Updates task.assignee_id
  - Creates audit log with from/to in context

**Implementation Notes**:
- All status transitions validated via models.validate_status_transition()
- Current user detected via config.get_current_user()
- Actor type detected via audit.get_actor_type()

---

#### commands/audit.py
**Purpose**: Audit trail viewing.

**Dependencies**: storage, models, typer, rich

**Commands**:
- `taskflow audit <id>`
  - Fetches audit logs for task_id
  - Displays Rich table (Timestamp, Actor, Type, Action, Details)
  - Sorts chronologically

- `taskflow audit --project <slug>`
  - Fetches all audit logs
  - Filters by entity_type="task" and task.project_id=slug
  - Displays Rich table

**Implementation Notes**:
- Timestamp formatted as YYYY-MM-DD HH:MM:SS
- Actor displayed with badge (ðŸ‘¤/@handle or ðŸ¤–/@handle)
- Context dict formatted as key=value pairs

---

#### commands/demo.py
**Purpose**: Automated demo script.

**Dependencies**: All command modules, typer, rich, time

**Commands**:
- `taskflow demo`
  - Runs scripted sequence (init â†’ register â†’ assign â†’ work â†’ audit)
  - No pauses (fast execution)
  - Completes in <90 seconds

- `taskflow demo -i` (interactive mode)
  - Same script with pauses between sections
  - Prompts "Press Enter to continue..."

**Implementation Notes**:
- Script hardcoded with sample data (@muhammad, @claude-code, etc.)
- Uses subprocess or direct function calls to execute commands
- Cleans up `.taskflow/` after completion (optional)

---

## 3. Implementation Sequence (3 Sprints)

### Sprint 1: Core Infrastructure (30 minutes)

**Goal**: Can initialize project and register workers.

**Tasks**:

1. **models.py** (10 min)
   - [ ] Define `Project` Pydantic model
   - [ ] Define `Worker` Pydantic model with agent validation
   - [ ] Define `Task` Pydantic model
   - [ ] Define `AuditLog` Pydantic model
   - [ ] Implement `VALID_TRANSITIONS` dict
   - [ ] Implement `validate_status_transition()` function
   - [ ] Write unit tests for model validation

2. **storage.py** (10 min)
   - [ ] Implement `Storage` class with file locking
   - [ ] Implement `initialize()` method
   - [ ] Implement `load_data()`, `save_data()` with locks
   - [ ] Implement `load_config()`, `save_config()`
   - [ ] Implement CRUD methods for Project, Worker, Task, AuditLog
   - [ ] Write unit tests for storage operations

3. **commands/init.py** (5 min)
   - [ ] Implement `taskflow init` command
   - [ ] Prompt for user @handle
   - [ ] Call storage.initialize()
   - [ ] Create default project
   - [ ] Display success message
   - [ ] Write integration test

4. **commands/project.py** (3 min)
   - [ ] Implement `taskflow project add` command
   - [ ] Implement `taskflow project list` command
   - [ ] Rich table display for project list
   - [ ] Write integration tests

5. **commands/worker.py** (2 min)
   - [ ] Implement `taskflow worker add` command
   - [ ] Implement `taskflow agent add` command
   - [ ] Implement `taskflow worker list` command
   - [ ] Rich table with emoji badges
   - [ ] Write integration tests

**Deliverable**: âœ… Can run `taskflow init`, add projects, register workers.

---

### Sprint 2: Task Management (20 minutes)

**Goal**: Can create, list, and view tasks.

**Tasks**:

1. **commands/task.py - Add** (8 min)
   - [ ] Implement `taskflow add` command with all options
   - [ ] Validate assignee exists
   - [ ] Validate parent exists (if specified)
   - [ ] Implement circular reference detection
   - [ ] Call storage.add_task()
   - [ ] Create audit log entry
   - [ ] Write integration tests

2. **commands/task.py - List** (6 min)
   - [ ] Implement `taskflow list` command
   - [ ] Add filters: status, assignee, priority, tag, search
   - [ ] Implement search (case-insensitive substring)
   - [ ] Rich table display with color-coded status
   - [ ] Write integration tests for filtering

3. **commands/task.py - Show** (6 min)
   - [ ] Implement `taskflow show <id>` command
   - [ ] Fetch task details
   - [ ] Fetch subtasks (recursive query)
   - [ ] Fetch recent audit logs
   - [ ] Rich panel display (task + subtasks + audit)
   - [ ] Write integration tests

**Deliverable**: âœ… Can create tasks, list with filters, view details with subtasks.

---

### Sprint 3: Workflow & Demo (19 minutes)

**Goal**: Demo-ready workflow (start â†’ progress â†’ complete â†’ audit).

**Tasks**:

1. **commands/workflow.py - Basic** (9 min)
   - [ ] Implement `taskflow start <id>` command
   - [ ] Implement `taskflow progress <id> --percent N --note` command
   - [ ] Implement `taskflow complete <id>` command
   - [ ] Status transition validation for all three
   - [ ] Create audit logs
   - [ ] Write integration tests

2. **commands/workflow.py - Review** (4 min)
   - [ ] Implement `taskflow review <id>` command
   - [ ] Implement `taskflow approve <id>` command
   - [ ] Implement `taskflow reject <id> --reason` command
   - [ ] Status transition validation
   - [ ] Create audit logs
   - [ ] Write integration tests

3. **commands/workflow.py - Delegate** (2 min)
   - [ ] Implement `taskflow delegate <id> @worker --note` command
   - [ ] Validate new assignee exists
   - [ ] Update assignee_id
   - [ ] Create audit log with from/to
   - [ ] Write integration test

4. **commands/audit.py** (2 min)
   - [ ] Implement `taskflow audit <id>` command
   - [ ] Rich table display (timestamp, actor, action, details)
   - [ ] Sort chronologically
   - [ ] Write integration test

5. **commands/demo.py** (2 min)
   - [ ] Implement `taskflow demo` command (non-interactive)
   - [ ] Implement `taskflow demo -i` command (interactive)
   - [ ] Script: init â†’ register â†’ assign â†’ work â†’ audit
   - [ ] Write integration test verifying <90 second completion

**Deliverable**: âœ… Demo script runs end-to-end, proves human-agent parity.

---

## 4. Data Model Details

### Pydantic Models

#### Project
```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional

class Project(BaseModel):
    id: str = Field(..., pattern="^[a-z0-9_-]+$")
    name: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    owner_id: str = Field(..., pattern="^@[a-z0-9_-]+$")
    created_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        json_encoders = {datetime: lambda v: v.isoformat()}
```

#### Worker
```python
from typing import Literal, Optional, List
from pydantic import model_validator

class Worker(BaseModel):
    id: str = Field(..., pattern="^@[a-z0-9_-]+$")
    type: Literal["human", "agent"]
    name: str = Field(..., min_length=1, max_length=200)
    agent_type: Optional[Literal["claude", "qwen", "gemini", "custom"]] = None
    capabilities: Optional[List[str]] = Field(default_factory=list)
    created_at: datetime = Field(default_factory=datetime.utcnow)

    @model_validator(mode='after')
    def validate_agent_fields(self):
        if self.type == "agent" and not self.agent_type:
            raise ValueError("agent_type required for agent workers")
        if self.type == "human" and self.agent_type:
            raise ValueError("agent_type not allowed for human workers")
        return self

    class Config:
        json_encoders = {datetime: lambda v: v.isoformat()}
```

#### Task
```python
from typing import Literal, Optional, List

class Task(BaseModel):
    id: int = Field(..., ge=1)
    project_id: str = Field(..., pattern="^[a-z0-9_-]+$")
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    assignee_id: Optional[str] = Field(None, pattern="^@[a-z0-9_-]+$")
    created_by_id: str = Field(..., pattern="^@[a-z0-9_-]+$")
    parent_id: Optional[int] = Field(None, ge=1)
    status: Literal["pending", "in_progress", "review", "completed", "blocked"] = "pending"
    progress_percent: int = Field(default=0, ge=0, le=100)
    priority: Literal["low", "medium", "high", "urgent"] = "medium"
    tags: List[str] = Field(default_factory=list)
    due_date: Optional[datetime] = None
    recurrence: Optional[Literal["daily", "weekly", "monthly", "yearly"]] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        json_encoders = {datetime: lambda v: v.isoformat()}
```

#### AuditLog
```python
from typing import Union

class AuditLog(BaseModel):
    id: int = Field(..., ge=1)
    entity_type: Literal["project", "worker", "task"]
    entity_id: Union[str, int]  # project_id (str), worker_id (str), task_id (int)
    action: str  # created, started, progressed, completed, assigned, etc.
    actor_id: str = Field(..., pattern="^@[a-z0-9_-]+$")
    actor_type: Literal["human", "agent"]
    context: dict = Field(default_factory=dict)
    created_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        json_encoders = {datetime: lambda v: v.isoformat()}
```

### JSON Storage Structure

**`.taskflow/config.json`**:
```json
{
  "default_project": "taskflow",
  "current_user": "@muhammad",
  "storage_mode": "json",
  "version": "1.0.0"
}
```

**`.taskflow/data.json`**:
```json
{
  "projects": [
    {
      "id": "taskflow",
      "name": "TaskFlow Platform",
      "description": null,
      "owner_id": "@muhammad",
      "created_at": "2025-12-07T10:00:00Z"
    }
  ],
  "workers": [
    {
      "id": "@muhammad",
      "type": "human",
      "name": "Muhammad Junaid",
      "agent_type": null,
      "capabilities": [],
      "created_at": "2025-12-07T10:00:00Z"
    },
    {
      "id": "@claude-code",
      "type": "agent",
      "name": "Claude Code",
      "agent_type": "claude",
      "capabilities": ["coding", "architecture"],
      "created_at": "2025-12-07T10:01:00Z"
    }
  ],
  "tasks": [
    {
      "id": 1,
      "project_id": "taskflow",
      "title": "Implement MCP server",
      "description": null,
      "assignee_id": "@claude-code",
      "created_by_id": "@muhammad",
      "parent_id": null,
      "status": "in_progress",
      "progress_percent": 60,
      "priority": "high",
      "tags": ["api", "mcp"],
      "due_date": null,
      "recurrence": null,
      "created_at": "2025-12-07T10:02:00Z",
      "updated_at": "2025-12-07T10:30:00Z"
    }
  ],
  "audit_logs": [
    {
      "id": 1,
      "entity_type": "task",
      "entity_id": 1,
      "action": "created",
      "actor_id": "@muhammad",
      "actor_type": "human",
      "context": {"title": "Implement MCP server", "assigned_to": "@claude-code"},
      "created_at": "2025-12-07T10:02:00Z"
    },
    {
      "id": 2,
      "entity_type": "task",
      "entity_id": 1,
      "action": "started",
      "actor_id": "@claude-code",
      "actor_type": "agent",
      "context": {},
      "created_at": "2025-12-07T10:05:00Z"
    },
    {
      "id": 3,
      "entity_type": "task",
      "entity_id": 1,
      "action": "progressed",
      "actor_id": "@claude-code",
      "actor_type": "agent",
      "context": {"percent": 60, "note": "Handlers implemented"},
      "created_at": "2025-12-07T10:30:00Z"
    }
  ],
  "_metadata": {
    "next_task_id": 2,
    "next_audit_id": 4
  }
}
```

### Phase Continuity Considerations

**Phase I â†’ II Migration (Pydantic â†’ SQLModel)**:

```python
# Phase I (Pydantic)
from pydantic import BaseModel, Field

class Task(BaseModel):
    id: int = Field(..., ge=1)
    title: str = Field(..., min_length=1, max_length=200)
    # ...

# Phase II (SQLModel) - minimal changes!
from sqlmodel import SQLModel, Field

class Task(SQLModel, table=True):
    id: int = Field(primary_key=True)
    title: str = Field(..., min_length=1, max_length=200)
    project_id: str = Field(foreign_key="project.id")
    # ... (same fields, add foreign keys)
```

**Key Points**:
- Field names identical across phases
- Data types compatible (int, str, datetime)
- JSON structure maps directly to database rows
- Audit trail structure never changes (append-only)

---

## 5. Test Strategy

### Test Structure

```
tests/
â”œâ”€â”€ conftest.py              # Shared fixtures
â”œâ”€â”€ test_models.py           # Unit: Pydantic validation
â”œâ”€â”€ test_storage.py          # Unit: Storage CRUD
â”œâ”€â”€ test_audit.py            # Unit: Audit logging
â”œâ”€â”€ test_init.py             # Integration: init command
â”œâ”€â”€ test_project.py          # Integration: project commands
â”œâ”€â”€ test_worker.py           # Integration: worker commands
â”œâ”€â”€ test_task.py             # Integration: task commands
â”œâ”€â”€ test_workflow.py         # Integration: workflow commands
â””â”€â”€ test_demo.py             # Integration: demo script
```

### Unit Tests (models.py, storage.py)

**Test Coverage**:
- âœ… Model validation (required fields, format constraints)
- âœ… Status transition validation (valid/invalid transitions)
- âœ… Worker validation (agent_type requirements)
- âœ… Storage CRUD operations
- âœ… File locking behavior
- âœ… Auto-increment ID assignment

**Example Test**:
```python
def test_status_transition_invalid():
    with pytest.raises(ValueError, match="Invalid status transition"):
        validate_status_transition("pending", "completed")
```

### Integration Tests (CLI commands)

**Test Coverage**:
- âœ… `taskflow init` creates directory and files
- âœ… `taskflow project add` creates project
- âœ… `taskflow worker add` registers workers
- âœ… `taskflow add` creates task with validation
- âœ… `taskflow list` filters correctly
- âœ… `taskflow start` changes status
- âœ… `taskflow audit` displays logs

**Example Test**:
```python
def test_workflow_start_task(initialized_storage, sample_task):
    runner = CliRunner()
    result = runner.invoke(app, ["start", "1"])

    assert result.exit_code == 0
    task = initialized_storage.get_task(1)
    assert task.status == "in_progress"
```

### Demo as Acceptance Test

**Test Coverage**:
- âœ… Demo completes without errors
- âœ… Demo runs in < 90 seconds
- âœ… All key commands execute (init, add, start, audit)
- âœ… Audit trail shows human-agent parity

---

## 6. Key Technical Decisions

### Decision 1: Typer over Click/argparse
**Rationale**: Modern type hints, auto-generated help, less boilerplate.

### Decision 2: Rich for Terminal Output
**Rationale**: Professional tables, color-coded status, emoji badges for actor types.

### Decision 3: JSON Storage with File Locking
**Rationale**: Simple for Phase I, forward-compatible, human-readable.

### Decision 4: Pydantic â†’ SQLModel Migration Path
**Rationale**: Zero-friction migration to database in Phase II.

### Decision 5: Status Transition Validation via Dict
**Rationale**: Simple finite state machine, clear error messages.

---

## Success Validation

### Pre-Flight Checklist
- [ ] Constitution check passed (all 5 principles)
- [ ] Spec complete (40 functional requirements)
- [ ] Plan complete (this document)

### Implementation Checklist
- [ ] Sprint 1 complete (init, projects, workers)
- [ ] Sprint 2 complete (tasks: add, list, show)
- [ ] Sprint 3 complete (workflow, audit, demo)
- [ ] All tests passing (unit + integration)
- [ ] Demo completes in < 90 seconds
- [ ] Audit trail shows human-agent parity

### Phase Continuity Checklist
- [ ] Pydantic models ready for SQLModel migration
- [ ] JSON structure matches future database schema
- [ ] Audit log format persists through all phases

---

## Next Steps

1. **Generate tasks.md** via `/sp.tasks` command
2. **Implement Sprint 1** (Core Infrastructure)
3. **Implement Sprint 2** (Task Management)
4. **Implement Sprint 3** (Workflow & Demo)
5. **Run tests** and verify success criteria
6. **Record demo video** (<90 seconds)
7. **Submit Phase I**

**Target**: Demo-ready CLI in 69 minutes. â±ï¸

---

**End of Implementation Plan**
